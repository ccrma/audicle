%{

/*----------------------------------------------------------------------------
    ChucK Concurrent, On-the-fly Audio Programming Language
      Compiler and Virtual Machine

    Copyright (c) 2004 Ge Wang and Perry R. Cook.  All rights reserved.
      http://chuck.cs.princeton.edu/
      http://soundlab.cs.princeton.edu/

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
    U.S.A.
-----------------------------------------------------------------------------*/

//-----------------------------------------------------------------------------
// file: chuck.tab.c
// desc: chuck parser
//
// author: Ge Wang (gewang@cs.princeton.edu) - generated by yacc
//         Perry R. Cook (prc@cs.princeton.edu)
//
// based in part on the ansi C grammar by Jeff Lee, maintained by Jutta Degener
//
// date: Summer 2002
//-----------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "chuck_utils.h"
#include "chuck_errmsg.h"
#include "chuck_absyn.h"

// function
int yylex( void );

void yyerror( char *s )
{
    EM_error( EM_tokPos, "%s", s );
}

a_Program g_program = NULL;

%}


%union
{
    int pos;
    int ival;
    double fval;
    c_str sval;
    
    a_Program program;
    a_Section program_section;
    a_Stmt_List stmt_list;
    a_Class_Def class_def;
    a_Class_Ext class_ext;
    a_Class_Body class_body;
    a_Stmt stmt;
    a_Exp exp;
    a_Func_Def func_def;
    a_Var_Decl_List var_decl_list;
    a_Var_Decl var_decl;
    a_Type_Decl type_decl;
    a_Arg_List arg_list;
    a_Id_List id_list;
};

// expect 26 shift/reduce conflicts
%expect 26

%token <sval> ID STRING_LIT
%token <ival> NUM
%token <fval> FLOAT

%token
  POUND COMMA COLON SEMICOLON LPAREN RPAREN
  LBRACK RBRACK LBRACE RBRACE DOT
  PLUS MINUS TIMES DIVIDE PERCENT
  EQ NEQ LT LE GT GE AND OR ASSIGN
  IF THEN ELSE WHILE FOR DO
  BREAK NULL_TOK FUNCTION RETURN
  QUESTION EXCLAMATION S_OR S_AND S_XOR
  PLUSPLUS MINUSMINUS
  SIMULT PATTERN CODE TRANSPORT HOST
  TIME WHENEVER NEXT UNTIL EVERY BEFORE
  AFTER AT AT_SYM ATAT_SYM NEW
  PLUS_CHUCK MINUS_CHUCK TIMES_CHUCK
  DIVIDE_CHUCK S_AND_CHUCK S_OR_CHUCK
  S_XOR_CHUCK SHIFT_RIGHT_CHUCK
  SHIFT_LEFT_CHUCK PERCENT_CHUCK
  SHIFT_RIGHT SHIFT_LEFT TILDA CHUCK
  COLONCOLON S_CHUCK AT_CHUCK LEFT_S_CHUCK
  UNCHUCK CLASS EXTENDS IMPLEMENTS PUBLIC
  PROTECTED PRIVATE STATIC CONST SPORK
  L_NSPC R_NSPC


%type <program> program
%type <program_section> program_section
%type <stmt> code_segment
%type <func_def> function_definition
%type <class_def> class_definition
%type <class_body> class_body
%type <class_ext> class_ext
%type <program_section> class_section
%type <stmt_list> statement_list
%type <stmt> statement
//%type <stmt_label> label_statement
%type <stmt> loop_statement
%type <stmt> selection_statement
%type <stmt> jump_statement
%type <stmt> expression_statement
%type <exp> expression
%type <exp> chuck_expression
%type <exp> conditional_expression
%type <exp> logical_or_expression
%type <exp> logical_and_expression
%type <exp> inclusive_or_expression
%type <exp> exclusive_or_expression
%type <exp> and_expression
%type <exp> equality_expression
%type <exp> relational_expression
%type <exp> shift_expression
%type <exp> additive_expression
%type <exp> multiplicative_expression
%type <exp> tilda_expression
%type <exp> cast_expression
%type <exp> unary_expression
%type <exp> postfix_expression
%type <exp> primary_expression
%type <exp> decl_expression
%type <ival> unary_operator
%type <ival> chuck_operator
%type <var_decl_list> var_decl_list
%type <var_decl> var_decl
%type <type_decl> type_decl
%type <ival> function_decl
%type <arg_list> arg_list
%type <id_list> id_list

%start program

%%

program
        : program_section                   { $$ = g_program = new_program( $1, EM_lineNum ); }
        | program_section program           { $$ = g_program = prepend_program( $1, $2, EM_lineNum ); }
        ;
        
program_section
        : statement_list                    { $$ = new_section_stmt( $1, EM_lineNum ); }
        | function_definition               { $$ = new_section_func_def( $1, EM_lineNum ); }
        | class_definition                  { $$ = new_section_class_def( $1, EM_lineNum ); }
        ;

class_definition
        : CLASS ID LBRACE class_body RBRACE
            { $$ = new_class_def( $2, NULL, $4, EM_lineNum ); }
        | CLASS ID class_ext LBRACE class_body RBRACE 
            { $$ = new_class_def( $2, $3, $5, EM_lineNum ); }
        ;

class_ext
        : IMPLEMENTS id_list                { $$ = new_class_ext( NULL, $2, EM_lineNum ); }
        | IMPLEMENTS id_list EXTENDS ID     { $$ = new_class_ext( $4, $2, EM_lineNum ); }
        | EXTENDS ID                        { $$ = new_class_ext( $2, NULL, EM_lineNum ); }
        | EXTENDS ID IMPLEMENTS id_list     { $$ = new_class_ext( $2, $4, EM_lineNum ); }
        ;

class_body
        : class_section                     { $$ = new_class_body( $1, EM_lineNum ); }
        | class_section class_body          { $$ = prepend_class_body( $1, $2, EM_lineNum ); }
        ;

class_section
        : statement_list                    { $$ = new_section_stmt( $1, EM_lineNum ); }
        | function_definition               { $$ = new_section_func_def( $1, EM_lineNum ); }
        ;

id_list
        : ID                                { $$ = new_id_list( $1, EM_lineNum ); }
        | ID COMMA id_list                  { $$ = prepend_id_list( $1, $3, EM_lineNum ); }
        ;
        
function_definition
        : function_decl type_decl ID LPAREN arg_list RPAREN code_segment
            { $$ = new_func_def( $1, $2, $3, $5, $7, EM_lineNum ); }
        | function_decl type_decl ID LPAREN RPAREN code_segment
            { $$ = new_func_def( $1, $2, $3, NULL, $6, EM_lineNum ); }
        ;

function_decl
        : FUNCTION                          { $$ = ae_func_func; }
        | PUBLIC                            { $$ = ae_func_public; }
        | PROTECTED                         { $$ = ae_func_protected; }
        | PRIVATE                           { $$ = ae_func_private; }
        ;

type_decl
        : ID                                { $$ = new_type_decl( $1, EM_lineNum ); }
        | type_decl LBRACK RBRACK           { $$ = new_type_decl_array( $1, EM_lineNum ); }
        ;

arg_list
        : type_decl ID                      { $$ = new_arg_list( $1, $2, EM_lineNum ); }
        | type_decl ID COMMA arg_list       { $$ = prepend_arg_list( $1, $2, $4, EM_lineNum ); }
        ;

statement_list
        : statement                         { $$ = new_stmt_list( $1, EM_lineNum ); }
        | statement statement_list          { $$ = prepend_stmt_list( $1, $2, EM_lineNum ); }
        ;
        
statement
        : expression_statement              { $$ = $1; }
        | loop_statement                    { $$ = $1; }
        | selection_statement               { $$ = $1; }
        | jump_statement                    { $$ = $1; }
        //| label_statement                   { }
        | code_segment                      { $$ = $1; }
        ;

jump_statement
        : RETURN SEMICOLON                  { $$ = new_stmt_from_return( NULL, EM_lineNum ); }
        | RETURN expression SEMICOLON       { $$ = new_stmt_from_return( $2, EM_lineNum ); }
        ;

selection_statement
        : IF LPAREN expression RPAREN statement
            { $$ = new_stmt_from_if( $3, $5, NULL, EM_lineNum ); }
        | IF LPAREN expression RPAREN statement ELSE statement
            { $$ = new_stmt_from_if( $3, $5, $7, EM_lineNum ); }
        ;
        
loop_statement
        : WHILE LPAREN expression RPAREN statement
            { $$ = new_stmt_from_while( $3, $5, EM_lineNum ); }
        | DO statement WHILE LPAREN expression RPAREN SEMICOLON
            { $$ = new_stmt_from_do_while( $5, $2, EM_lineNum ); }
        | FOR LPAREN expression_statement expression_statement RPAREN statement
            { $$ = new_stmt_from_for( $3, $4, NULL, $6, EM_lineNum ); }
        | FOR LPAREN expression_statement expression_statement expression RPAREN statement
            { $$ = new_stmt_from_for( $3, $4, $5, $7, EM_lineNum ); }
        | UNTIL LPAREN expression RPAREN statement
            { $$ = new_stmt_from_until( $3, $5, EM_lineNum ); }
        | DO statement UNTIL LPAREN expression RPAREN SEMICOLON
            { $$ = new_stmt_from_do_until( $5, $2, EM_lineNum ); }
        ;
                
code_segment
        : LBRACE RBRACE                     { $$ = NULL; }
        | LBRACE statement_list RBRACE      { $$ = new_stmt_from_code( $2, EM_lineNum ); }
        ;
        
expression_statement
        : SEMICOLON                         { $$ = NULL; }
        | expression SEMICOLON              { $$ = new_stmt_from_expression( $1, EM_lineNum ); }
        ;
        
expression
        : chuck_expression                  { $$ = $1; }
        | chuck_expression COMMA expression { $$ = prepend_expression( $1, $3, EM_lineNum ); }
        ;

chuck_expression
        : decl_expression                   { $$ = $1; }
        // | rassign_expression                   { $$ = $1; }
        | chuck_expression chuck_operator decl_expression
            { $$ = new_exp_from_binary( $1, $2, $3, EM_lineNum ); }
        ;
        
decl_expression
        : conditional_expression            { $$ = $1; }
        | ID var_decl_list                  { $$ = new_exp_decl( $1, $2, EM_lineNum ); }
        | AT_SYM var_decl_list              { $$ = new_exp_decl( NULL, $2, EM_lineNum ); }
        ;

var_decl_list
        : var_decl                          { $$ = new_var_decl_list( $1, EM_lineNum ); }
        // | var_decl COMMA var_decl_list      { $$ = prepend_var_decl_list( $1, $3, EM_lineNum ); }
        ;

var_decl
        : ID                                { $$ = new_var_decl( $1, EM_lineNum ); }
        | var_decl LBRACK RBRACK            { $$ = new_var_decl2( $1, 1, NULL, EM_lineNum ); }
        | var_decl LBRACK expression RBRACK { $$ = new_var_decl2( $1, 1, $3, EM_lineNum ); }
        ;
        
chuck_operator
        : CHUCK                             { $$ = ae_op_chuck; }
        | S_CHUCK                           { $$ = ae_op_s_chuck; }
        | AT_CHUCK                          { $$ = ae_op_at_chuck; }
        | PLUS_CHUCK                        { $$ = ae_op_plus_chuck; }
        | MINUS_CHUCK                       { $$ = ae_op_minus_chuck; }
        | TIMES_CHUCK                       { $$ = ae_op_times_chuck; }
        | DIVIDE_CHUCK                      { $$ = ae_op_divide_chuck; }
        | S_AND_CHUCK                       { $$ = ae_op_s_and_chuck; }
        | S_OR_CHUCK                        { $$ = ae_op_s_or_chuck; }
        | S_XOR_CHUCK                       { $$ = ae_op_s_xor_chuck; }
        | SHIFT_RIGHT_CHUCK                 { $$ = ae_op_shift_right_chuck; }
        | SHIFT_LEFT_CHUCK                  { $$ = ae_op_shift_left_chuck; }
        | PERCENT_CHUCK                     { $$ = ae_op_percent_chuck; }
        | UNCHUCK                           { $$ = ae_op_unchuck; }
        ;

conditional_expression
        : logical_or_expression             { $$ = $1; }
        | logical_or_expression QUESTION expression COLON conditional_expression
            { $$ = new_exp_from_if( $1, $3, $5, EM_lineNum ); }
        ;

logical_or_expression
        : logical_and_expression            { $$ = $1; }
        | logical_or_expression OR logical_and_expression
            { $$ = new_exp_from_binary( $1, ae_op_or, $3, EM_lineNum ); }
        ;

logical_and_expression
        : inclusive_or_expression           { $$ = $1; }
        | logical_and_expression AND inclusive_or_expression
            { $$ = new_exp_from_binary( $1, ae_op_and, $3, EM_lineNum ); }
        ;
        
inclusive_or_expression
        : exclusive_or_expression           { $$ = $1; }
        | inclusive_or_expression S_OR exclusive_or_expression
            { $$ = new_exp_from_binary( $1, ae_op_s_or, $3, EM_lineNum ); }
        ;
        
exclusive_or_expression
        : and_expression                    { $$ = $1; }
        | exclusive_or_expression S_XOR and_expression
            { $$ = new_exp_from_binary( $1, ae_op_s_xor, $3, EM_lineNum ); }
        ;
        
and_expression
        : equality_expression               { $$ = $1; }
        | and_expression S_AND equality_expression
            { $$ = new_exp_from_binary( $1, ae_op_s_and, $3, EM_lineNum ); }
        ;
        
equality_expression
        : relational_expression             { $$ = $1; }
        | equality_expression EQ relational_expression
            { $$ = new_exp_from_binary( $1, ae_op_eq, $3, EM_lineNum ); }
        | equality_expression NEQ relational_expression
            { $$ = new_exp_from_binary( $1, ae_op_neq, $3, EM_lineNum ); }
        ;

relational_expression
        : shift_expression                  { $$ = $1; }
        | relational_expression LT shift_expression
            { $$ = new_exp_from_binary( $1, ae_op_lt, $3, EM_lineNum ); }
        | relational_expression GT shift_expression
            { $$ = new_exp_from_binary( $1, ae_op_gt, $3, EM_lineNum ); }
        | relational_expression LE shift_expression
            { $$ = new_exp_from_binary( $1, ae_op_le, $3, EM_lineNum ); }
        | relational_expression GE shift_expression
            { $$ = new_exp_from_binary( $1, ae_op_ge, $3, EM_lineNum ); }
        ;

shift_expression
        : additive_expression               { $$ = $1; }
        | shift_expression SHIFT_LEFT additive_expression
            { $$ = new_exp_from_binary( $1, ae_op_shift_left, $3, EM_lineNum ); }
        | shift_expression SHIFT_RIGHT additive_expression
            { $$ = new_exp_from_binary( $1, ae_op_shift_right, $3, EM_lineNum ); }
        ;

additive_expression
        : multiplicative_expression          { $$ = $1; }
        | additive_expression PLUS multiplicative_expression
            { $$ = new_exp_from_binary( $1, ae_op_plus, $3, EM_lineNum ); }
        | additive_expression MINUS multiplicative_expression
            { $$ = new_exp_from_binary( $1, ae_op_minus, $3, EM_lineNum ); }
        ;
        
multiplicative_expression
        : tilda_expression                   { $$ = $1; }
        | multiplicative_expression TIMES tilda_expression
            { $$ = new_exp_from_binary( $1, ae_op_times, $3, EM_lineNum ); }
        | multiplicative_expression DIVIDE tilda_expression
            { $$ = new_exp_from_binary( $1, ae_op_divide, $3, EM_lineNum ); }
        | multiplicative_expression PERCENT tilda_expression
            { $$ = new_exp_from_binary( $1, ae_op_percent, $3, EM_lineNum ); }
        ;

tilda_expression
        : cast_expression                   { $$ = $1; }
        | tilda_expression TILDA cast_expression
            { $$ = new_exp_from_binary( $1, ae_op_tilda, $3, EM_lineNum ); }
        ;
        
cast_expression
        : unary_expression                  { $$ = $1; }
        | LPAREN ID RPAREN cast_expression  { $$ = new_exp_from_cast( $2, $4, EM_lineNum ); }
        //| LT ID GT cast_expression          { $$ = new_exp_from_cast( $2, $4, EM_lineNum ); }
        ;
        
unary_expression
        : postfix_expression                { $$ = $1; }
        | PLUSPLUS unary_expression
            { $$ = new_exp_from_unary( ae_op_plusplus, $2, EM_lineNum ); }
        | MINUSMINUS unary_expression
            { $$ = new_exp_from_unary( ae_op_minusminus, $2, EM_lineNum ); }
        | unary_operator cast_expression
            { $$ = new_exp_from_unary( $1, $2, EM_lineNum ); }
        //| SIZEOF unary_expression         { }
        ;
        
unary_operator
        : PLUS                              { $$ = ae_op_plus; }
        | MINUS                             { $$ = ae_op_minus; }
        | TILDA                             { $$ = ae_op_tilda; }
        | EXCLAMATION                       { $$ = ae_op_exclamation; }
        | S_AND                             { $$ = ae_op_s_and; }
        | TIMES                             { $$ = ae_op_times; }
        | SPORK TILDA                       { $$ = ae_op_spork; }
        ;
        
postfix_expression
        : primary_expression                { $$ = $1; }
        | postfix_expression LBRACK expression RBRACK
            { $$ = new_exp_from_array( $1, $3, EM_lineNum ); }
        | postfix_expression LPAREN RPAREN
            { $$ = new_exp_from_func_call( $1, NULL, EM_lineNum ); }
        | postfix_expression LPAREN expression RPAREN
            { $$ = new_exp_from_func_call( $1, $3, EM_lineNum ); }
        | postfix_expression DOT ID
            { $$ = new_exp_from_member_dot( $1, $3, EM_lineNum ); }
        | postfix_expression PLUSPLUS
            { $$ = new_exp_from_postfix( $1, ae_op_plusplus, EM_lineNum ); }
        | postfix_expression MINUSMINUS
            { $$ = new_exp_from_postfix( $1, ae_op_minusminus, EM_lineNum ); }
        | postfix_expression COLONCOLON primary_expression
            { $$ = new_exp_from_dur( $1, $3, EM_lineNum ); }
        //| postfix_expression RARROW ID    { }
        ;

primary_expression
        : ID                                { $$ = new_exp_from_id( $1, EM_lineNum ); }
        | NUM                               { $$ = new_exp_from_int( $1, EM_lineNum ); }
        | FLOAT                             { $$ = new_exp_from_float( $1, EM_lineNum ); }
        | STRING_LIT                        { $$ = new_exp_from_str( $1, EM_lineNum ); }
        | L_NSPC R_NSPC                     { $$ = new_exp_from_namespace( "", EM_lineNum ); }
        | L_NSPC ID R_NSPC                  { $$ = new_exp_from_namespace( $2, EM_lineNum ); }
        | LPAREN expression RPAREN          { $$ = $2; }
        ;

